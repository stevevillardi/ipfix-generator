import sys
import argparse
import random
import socket
import struct
import time
import ipaddress
import csv
import os
from io import BytesIO
import base64
from scapy.all import IP, UDP, Raw, send
from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, 
                             QPushButton, QTextEdit, QSpinBox, QDoubleSpinBox, QTableWidget, 
                             QTableWidgetItem, QFileDialog, QSplitter, QStatusBar)
from PyQt5.QtCore import (QThread, pyqtSignal, Qt)
from PyQt5.QtGui import QPixmap, QImage

LOGO_BASE64 = """
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
"""

def parse_ip_ranges(ip_ranges):
    ip_list = []
    for ip_range in ip_ranges.split(','):
        ip_range = ip_range.strip()
        try:
            if '/' in ip_range:
                ip_list.extend([str(ip) for ip in ipaddress.IPv4Network(ip_range, strict=False)])
            else:
                ipaddress.IPv4Address(ip_range)
                ip_list.append(ip_range)
        except ValueError:
            print(f"Invalid IP address or range: {ip_range}")
    return ip_list

def generate_flows(flow_src_ips, flow_dst_ips, num_flows=1000):
    flows = []
    for _ in range(num_flows):            
        # Common ports
        ports = [
            (20, "FTP Data Transfer"),  # File Transfer Protocol - Data Stream
            (21, "FTP Control"),  # File Transfer Protocol - Control Stream
            (22, "SSH"),  # Secure Shell - used for secure logins, file transfers (scp, sftp) and port forwarding
            (23, "Telnet"),  # Telnet protocol - unencrypted text communications
            (25, "SMTP"),  # Simple Mail Transfer Protocol - sending email
            (53, "DNS"),  # Domain Name System - translating domain names to IP addresses
            (80, "HTTP"),  # Hypertext Transfer Protocol - used for unencrypted web browsing
            (110, "POP3"),  # Post Office Protocol - used by email clients to retrieve emails from a server
            (119, "NNTP"),  # Network News Transfer Protocol - used for accessing newsgroups
            (123, "NTP"),  # Network Time Protocol - used for clock synchronization between computer systems
            (143, "IMAP"),  # Internet Message Access Protocol - used by email clients to retrieve emails from a server
            (389, "LDAP"),  # Lightweight Directory Access Protocol - used for accessing and maintaining distributed directory information services
            (443, "HTTPS"),  # HTTP Secure - used for secure web browsing
            (465, "SMTPS"),  # SMTP over SSL - used for sending email securely
            (500, "ISAKMP"),  # Internet Security Association and Key Management Protocol - used for establishing Security Associations (SA) in IPsec
            (515, "LPD"),  # Line Printer Daemon - used for print services
            (636, "LDAPS"),  # LDAP over SSL - secure version of LDAP
            (993, "IMAPS"),  # IMAP over SSL - used for retrieving email securely
            (995, "POP3S"),  # POP3 over SSL - used for retrieving email securely
            (1433, "MS SQL"),  # Microsoft SQL Server database management system
            (1521, "Oracle"),  # Oracle database default listener
            (3306, "MySQL"),  # MySQL database system
            (3389, "RDP"),  # Remote Desktop Protocol - used for remote access to Windows desktops
            (5060, "SIP"),  # Session Initiation Protocol - used for VoIP and video calls
            (5061, "SIP TLS"),  # SIP over TLS - secure version of SIP
            (5432, "PostgreSQL"),  # PostgreSQL database system
            (8080, "HTTP Alternate"),  # Commonly used for web servers as an alternative to port 80
            (8443, "HTTPS Alternate")  # Commonly used for secure web servers as an alternative to port 443
        ]

        #Source: https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml
        protocols = {
            1: "ICMP",
            6: "TCP",
            17: "UDP"
        }

        if flow_src_ips:
            src_ip = random.choice(flow_src_ips)
        else:
            src_ip = f"{random.randint(1, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"

        if flow_dst_ips:
            dst_ip = random.choice(flow_dst_ips)
        else:
            dst_ip = f"{random.randint(1, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"

        dst_port, dst_port_name = random.choice(ports)

        flow = {
            'src_ip': src_ip,
            'dst_ip': dst_ip,
            'dst_port': dst_port,
            'protocol': random.choice(list(protocols.keys())),
            'ingress_interface' : random.randint(0, 65535),
            'egress_interface' : random.randint(0, 65535)
        }
        flows.append(flow)
    
    return flows

class IPFIXGeneratorThread(QThread):
    update_signal = pyqtSignal(str)
    flow_signal = pyqtSignal(dict)
    stats_signal = pyqtSignal(int)  # New signal for updating total flows sent

    def __init__(self, source_ips, destination_ip, destination_port, num_flows, interval, packets_per_interval, flows_per_packet, flow_src_ips, flow_dst_ips, flows):
        QThread.__init__(self)
        self.source_ips = source_ips
        self.destination_ip = destination_ip
        self.destination_port = destination_port
        self.num_flows = num_flows
        self.interval = interval
        self.flows = flows
        self.packets_per_interval = packets_per_interval
        self.flows_per_packet = flows_per_packet
        self.flow_src_ips = flow_src_ips
        self.flow_dst_ips = flow_dst_ips
        self.is_running = True
        self.template_refresh_interval = 60  # Send template every 60 seconds
        self.sequence_number = 0
        self.last_template_time = 0
        self.observation_domain_id = random.randint(0, 2**32 - 1)
        self.total_flows_sent = 0  # New counter for total flows sent
        self.current_flow_index = 0

    def generate_ipfix_header(self, length, is_data_record=False):
        version = 10
        export_time = int(time.time())
        sequence_number = self.sequence_number if is_data_record else 0
        
        header = struct.pack('!HHLLL',
            version,
            length,
            export_time,
            sequence_number,
            self.observation_domain_id
        )
        
        if is_data_record:
            self.sequence_number += 1
        
        return header

    def generate_ipfix_template(self):
        template_id = 257
        field_count = 16
        
        # Pack the field specifiers first to get the correct length
        field_specifiers = struct.pack('!HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH',
            8, 4,   # sourceIPv4Address
            12, 4,  # destinationIPv4Address
            7, 2,   # sourceTransportPort
            11, 2,  # destinationTransportPort
            4, 1,   # protocolIdentifier
            5, 1,   # ipClassOfService (optional)
            2, 4,   # inPacketDeltaCount
            24, 4,  # outPacketDeltaCount
            1, 4,   # inOctetDeltaCount
            23, 4,  # outOctetDeltaCount
            152, 8, # flowStartMilliseconds (optional ASA only)
            153, 8, # flowEndMilliseconds
            10, 4,  # ingressInterface
            14, 4,  # egressInterface
            95, 4,  # applicationId
            94, 2  # applicationName
        )
        
        # Calculate the total length of the template set
        total_length = 4 + 4 + len(field_specifiers)  # 4 bytes for set header, 4 bytes for template header
        
        template_set_header = struct.pack('!HH', 2, total_length)  # FlowSet ID = 2 for templates
        template_header = struct.pack('!HH', template_id, field_count)
        
        return template_set_header + template_header + field_specifiers

    def generate_ipfix_data_record(self):

        # NBAR application data 
        # Source: https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/qos_nbar/prot_lib/config_library/pp6000/nbar-prot-pack6000/nbar-prot-pack6000_CLT_chapter.html
        nbar_applications = [
            (1454, "facebook", "Social Networking"),
            (82, "youtube", "Streaming Media"),
            (3, "http", "Web"),
            (1312, "ssl", "Network Protocol"),
            (1453, "twitter", "Social Networking"),
            (1456, "google-services", "Cloud and Data Center"),
            (72, "dns", "Network Protocol"),
            (1217, "slack", "Collaboration"),
            (31, "ntp", "Network Protocol"),
            (40, "ssh", "Network Protocol"),
            (1431, "ms-office-365", "Cloud and Data Center"),
            (1306, "webex-meeting", "Collaboration"),
            (1316, "netflix", "Streaming Media"),
            (1488, "whatsapp", "Social Networking"),
            (69, "bittorrent", "File Sharing")
        ]

        if self.current_flow_index >= len(self.flows):
            self.current_flow_index = 0
            self.update_signal.emit("End of flow array reached, replaying generated flow series.")

        flow = self.flows[self.current_flow_index]
        self.current_flow_index += 1

        src_ip = socket.inet_aton(flow['src_ip'])
        dst_ip = socket.inet_aton(flow['dst_ip'])
        src_port = random.randint(1024, 65535)
        dst_port = flow['dst_port']
        protocol = flow['protocol']
        ingress_interface = flow['ingress_interface']
        egress_interface = flow['egress_interface']

        tos = random.randint(0, 255)
        inpackets = random.randint(1, 1000)
        inoctets = inpackets * random.randint(64, 1500)
        outpackets = random.randint(1, 1000)
        outoctets = outpackets * random.randint(64, 1500)
        
        current_time_ms = int(time.time() * 1000)
        start_time = current_time_ms - random.randint(1000, 60000)
        end_time = current_time_ms

        application_id, application_name, application_category = random.choice(nbar_applications)
        
        record = struct.pack('!4s4sHHBBIIIIQQIIIH',
            src_ip,
            dst_ip,
            src_port,
            dst_port,
            protocol,
            tos,
            inpackets,
            outpackets,
            inoctets,
            outoctets,
            start_time,
            end_time,
            ingress_interface,
            egress_interface,
            application_id,
            len(application_name)
        )

        decoded_flow = {
            'src_ip': socket.inet_ntoa(src_ip),
            'dst_ip': socket.inet_ntoa(dst_ip),
            'src_port': src_port,
            'dst_port': dst_port,
            'protocol': str(protocol),
            'application': application_name,
            'application_category': application_category,
            'tos': tos,
            'in_packets': inpackets,
            'out_packets': inpackets,
            'in_octets': inoctets,
            'out_octets': inoctets,
            'start_time': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(start_time / 1000)),
            'end_time': time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(end_time / 1000))
        }
        self.flow_signal.emit(decoded_flow)

        return (record) 

    def send_ipfix(self, source_ips, destination_ip, destination_port, num_flows, interval, packets_per_interval, flows_per_packet):
        flowset_id = 257
        while self.is_running and (num_flows == 0 or num_flows > 0):
            current_time = time.time()
            
            # Send template if it's time
            if current_time - self.last_template_time >= self.template_refresh_interval:
                for source_ip in source_ips:
                    template = self.generate_ipfix_template()
                    template_length = len(template) + 16  # 16 is the size of the IPFIX header
                    template_header = self.generate_ipfix_header(template_length, is_data_record=False)
                    template_packet = IP(src=source_ip, dst=destination_ip) / UDP(sport=random.randint(1024, 65535), dport=destination_port) / Raw(load=template_header + template)
                    send(template_packet, verbose=False)
                    self.update_signal.emit(f"Sent IPFIX template from {source_ip} to {destination_ip}:{destination_port}")
                self.last_template_time = current_time

            # Send data flows
            flows_sent = 0
            while flows_sent < packets_per_interval:
                if not self.is_running or (num_flows > 0 and num_flows <= 0):
                    break
                
                # Determine number of flows for this packet
                if flows_per_packet == 0:
                    packet_flows = random.randint(1, 10)
                else:
                    packet_flows = min(flows_per_packet, packets_per_interval - flows_sent)
                
                data_records = b''
                for _ in range(packet_flows):
                    data_records += self.generate_ipfix_data_record()
                
                data_set_header = struct.pack('!HH', flowset_id, len(data_records) + 4)  # +4 for the set header itself
                total_length = 16 + len(data_set_header) + len(data_records)  # 16 is the size of the IPFIX header
                header = self.generate_ipfix_header(total_length, is_data_record=True)
                payload = header + data_set_header + data_records

                for source_ip in source_ips:
                    pkt = IP(src=source_ip, dst=destination_ip) / UDP(sport=random.randint(1024, 65535), dport=destination_port) / Raw(load=payload)
                    send(pkt, verbose=False)
                    self.update_signal.emit(f"Sent IPFIX packet with {packet_flows} flows from {source_ip} to {destination_ip}:{destination_port}")

                flows_sent += packet_flows
                self.total_flows_sent += packet_flows * len(source_ips)
                self.stats_signal.emit(self.total_flows_sent)

                if num_flows > 0:
                    num_flows -= packet_flows

            time.sleep(interval)

        self.update_signal.emit("Finished sending IPFIX traffic")

    def run(self):
        self.send_ipfix(self.source_ips, self.destination_ip, self.destination_port, self.num_flows, self.interval, self.packets_per_interval, self.flows_per_packet)

    def stop(self):
        self.is_running = False

class IPFIXGeneratorGUI(QWidget):
    def __init__(self, cli_args=None):
        super().__init__()
        self.cli_args = cli_args
        self.flows = []
        self.total_flows_sent = 0
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # Create a vertical splitter for the entire layout
        main_splitter = QSplitter(Qt.Vertical)
        
        # Add status bar
        self.status_bar = QStatusBar()
        self.status_bar.setFixedHeight(40)  # Increase status bar height
        
        # Add logo to status bar (left-aligned and larger)
        logo_label = QLabel()
        logo_pixmap = self.get_logo()
        if logo_pixmap:
            logo_label.setPixmap(logo_pixmap.scaledToHeight(30, Qt.SmoothTransformation))
            logo_label.setContentsMargins(5, 0, 5, 0)  # Add some horizontal padding
        self.status_bar.addWidget(logo_label)
        
        # Add a stretch to push other items to the right
        self.status_bar.addPermanentWidget(QWidget(), 1)

        self.source_hosts_label = QLabel("Source Hosts: 0")
        self.total_flows_label = QLabel("Total Flows Sent: 0")
        self.status_bar.addPermanentWidget(self.source_hosts_label)
        self.status_bar.addPermanentWidget(self.total_flows_label)
        main_layout.addWidget(self.status_bar)

        self.setWindowTitle('LogicMonitor Demo Engineering: IPFIX Generator')
        self.resize(1000, 800)  # Set a default size
        self.show()

        # Top section
        top_widget = QWidget()
        top_layout = QHBoxLayout(top_widget)

        # Left side: Input fields
        left_widget = QWidget()
        left_layout = QVBoxLayout(left_widget)
        self.add_input_fields(left_layout)

        # Button layout
        button_layout = QHBoxLayout()
        self.start_button = QPushButton("Start")
        self.start_button.clicked.connect(self.start_generation)
        button_layout.addWidget(self.start_button)

        self.stop_button = QPushButton("Stop")
        self.stop_button.clicked.connect(self.stop_generation)
        self.stop_button.setEnabled(False)
        button_layout.addWidget(self.stop_button)

        self.clear_button = QPushButton("Clear")
        self.clear_button.clicked.connect(self.clear_screen)
        button_layout.addWidget(self.clear_button)

        self.export_button = QPushButton("Export Flows")
        self.export_button.clicked.connect(self.export_flows)
        self.export_button.setEnabled(False)
        button_layout.addWidget(self.export_button)

        left_layout.addLayout(button_layout)

        # Right side: Log output
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)

        # Add widgets to the top layout
        top_layout.addWidget(left_widget)
        top_layout.addWidget(self.log_output)

        # Add top widget to the main splitter
        main_splitter.addWidget(top_widget)

        # Flow table
        self.flow_table = QTableWidget()
        self.flow_table.setColumnCount(11)
        self.flow_table.setHorizontalHeaderLabels(['Src IP', 'Dst IP', 'Src Port', 'Dst Port', 'Protocol', 
                                                   'Application', 'Category' ,'ToS', 'Packets', 'Octets', 'Start Time', 'End Time'])
        main_splitter.addWidget(self.flow_table)

        # Set the main layout
        main_layout.addWidget(main_splitter)

        self.setWindowTitle('Demo Engineering: IPFIX Generator')
        self.resize(1150, 800)  # Set a default size
        self.show()

    def get_logo(self):
        try:
            # Decode the base64 string to image data
            image_data = base64.b64decode(LOGO_BASE64)
            
            # Create a QImage from the image data
            image = QImage()
            image.loadFromData(image_data)
            
            # Convert QImage to QPixmap
            pixmap = QPixmap.fromImage(image)
            
            if pixmap.isNull():
                print("Failed to load logo")
                return None
            
            return pixmap
        except Exception as e:
            print(f"Error loading logo: {e}")
            return None

    def add_input_fields(self, layout):
        # Source IPs
        source_layout = QHBoxLayout()
        source_layout.addWidget(QLabel("Source IPs (comma-separated):"))
        self.source_ips = QLineEdit(self.cli_args.source if self.cli_args else "")
        source_layout.addWidget(self.source_ips)
        layout.addLayout(source_layout)

        # Destination IP
        dest_layout = QHBoxLayout()
        dest_layout.addWidget(QLabel("Destination IP:"))
        self.dest_ip = QLineEdit(self.cli_args.destination if self.cli_args else "")
        dest_layout.addWidget(self.dest_ip)
        layout.addLayout(dest_layout)

        # Destination Port
        dest_port_layout = QHBoxLayout()
        dest_port_layout.addWidget(QLabel("Destination Port:"))
        self.dest_port = QSpinBox()
        self.dest_port.setRange(1, 65535)
        self.dest_port.setValue(self.cli_args.port if self.cli_args else 2055)
        dest_port_layout.addWidget(self.dest_port)
        layout.addLayout(dest_port_layout)

        # Number of Flows
        flows_layout = QHBoxLayout()
        flows_layout.addWidget(QLabel("Number of Flows (0 for infinite):"))
        self.num_flows = QSpinBox()
        self.num_flows.setRange(0, 1000000)
        self.num_flows.setValue(self.cli_args.flows if self.cli_args else 0)
        flows_layout.addWidget(self.num_flows)
        layout.addLayout(flows_layout)

        # Interval
        interval_layout = QHBoxLayout()
        interval_layout.addWidget(QLabel("Interval (seconds):"))
        self.interval = QDoubleSpinBox()
        self.interval.setRange(0.1, 60)
        self.interval.setSingleStep(0.1)
        self.interval.setValue(self.cli_args.interval if self.cli_args else 1.0)
        interval_layout.addWidget(self.interval)
        layout.addLayout(interval_layout)

        # Flows per Interval
        packets_per_interval_layout = QHBoxLayout()
        packets_per_interval_layout.addWidget(QLabel("Packets per Interval:"))
        self.packets_per_interval = QSpinBox()
        self.packets_per_interval.setRange(1, 1000)
        self.packets_per_interval.setValue(self.cli_args.packets_per_interval if self.cli_args else 5)
        packets_per_interval_layout.addWidget(self.packets_per_interval)
        layout.addLayout(packets_per_interval_layout)

        # Flows per Packet
        flows_per_packet_layout = QHBoxLayout()
        flows_per_packet_layout.addWidget(QLabel("Flows per Packet (0 for random 1-10):"))
        self.flows_per_packet = QSpinBox()
        self.flows_per_packet.setRange(0, 1000)
        self.flows_per_packet.setValue(self.cli_args.flows_per_packet if self.cli_args else 0)
        flows_per_packet_layout.addWidget(self.flows_per_packet)
        layout.addLayout(flows_per_packet_layout)

        # Flow Source IPs
        flow_src_ips_layout = QVBoxLayout()
        flow_src_ips_layout.addWidget(QLabel("Flow Source IPs (comma-separated, CIDR allowed):"))
        self.flow_src_ips = QTextEdit()
        self.flow_src_ips.setPlaceholderText("Enter IP addresses or CIDR ranges, one per line or comma-separated")
        self.flow_src_ips.setFixedHeight(80)  # Adjust height as needed
        if self.cli_args and self.cli_args.flow_src_ips:
            self.flow_src_ips.setPlainText(self.cli_args.flow_src_ips)
        else:
            self.flow_src_ips.setPlainText("192.168.1.0/24")
        flow_src_ips_layout.addWidget(self.flow_src_ips)
        layout.addLayout(flow_src_ips_layout)

        # Flow Destination IPs
        flow_dst_ips_layout = QVBoxLayout()
        flow_dst_ips_layout.addWidget(QLabel("Flow Destination IPs (comma-separated, CIDR allowed):"))
        self.flow_dst_ips = QTextEdit()
        self.flow_dst_ips.setPlaceholderText("Enter IP addresses or CIDR ranges, one per line or comma-separated")
        self.flow_dst_ips.setFixedHeight(80)  # Adjust height as needed
        if self.cli_args and self.cli_args.flow_dst_ips:
            self.flow_dst_ips.setPlainText(self.cli_args.flow_dst_ips)
        else:
            self.flow_dst_ips.setPlainText("54.193.15.255/32,54.194.232.54/32,54.209.7.170/32,54.254.224.41/32,69.25.43.0/24")
        flow_dst_ips_layout.addWidget(self.flow_dst_ips)
        layout.addLayout(flow_dst_ips_layout)

    def clear_screen(self):
        # Clear the flow table
        self.flow_table.setRowCount(0)
        self.flows = []

        # Clear the log output
        self.log_output.clear()

        #Clear status bar
        self.total_flows_label.setText("Total Flows Sent: 0")
        self.source_hosts_label.setText(f"Source Hosts: 0")

    def start_generation(self):
        # Clear the flow table
        self.flow_table.setRowCount(0)
        self.flows = []

        # Clear the log output
        self.log_output.clear()

        # Reset total flows sent
        self.total_flows_sent = 0
        self.total_flows_label.setText("Total Flows Sent: 0")

        source_ips = [ip.strip() for ip in self.source_ips.text().split(',')]
        self.source_hosts_label.setText(f"Source Hosts: {len(source_ips)}")

        dest_ip = self.dest_ip.text()
        dest_port = self.dest_port.value()
        num_flows = self.num_flows.value()
        interval = self.interval.value()
        packets_per_interval = self.packets_per_interval.value()
        flows_per_packet = self.flows_per_packet.value()

        flow_src_ips = parse_ip_ranges(self.flow_src_ips.toPlainText()) if self.flow_src_ips.toPlainText() else []
        flow_dst_ips = parse_ip_ranges(self.flow_dst_ips.toPlainText()) if self.flow_dst_ips.toPlainText() else []
        
        # Generate flows
        num_flows_to_generate = 1000  # Generate at least 10000 flows or the specified number
        flows = generate_flows(flow_src_ips, flow_dst_ips, num_flows_to_generate)  # Assuming TCP (protocol 6)
        self.update_log(f"Generated {num_flows_to_generate} sample flows for generation")

        self.generator_thread = IPFIXGeneratorThread(source_ips, dest_ip, dest_port, num_flows, interval, packets_per_interval, flows_per_packet, flow_src_ips, flow_dst_ips, flows)
        self.generator_thread.update_signal.connect(self.update_log)
        self.generator_thread.flow_signal.connect(self.add_flow_to_table)
        self.generator_thread.stats_signal.connect(self.update_total_flows)
        self.generator_thread.start()

        self.start_button.setEnabled(False)
        self.stop_button.setEnabled(True)
        self.export_button.setEnabled(True)

        self.update_log("Started IPFIX traffic generation")

    def update_total_flows(self, total_flows):
        self.total_flows_sent = total_flows
        self.total_flows_label.setText(f"Total Flows Sent: {self.total_flows_sent}")

    def stop_generation(self):
        if hasattr(self, 'generator_thread'):
            self.generator_thread.stop()
            self.generator_thread.wait()

        self.start_button.setEnabled(True)
        self.stop_button.setEnabled(False)

    def update_log(self, message):
        self.log_output.append(message)

    def add_flow_to_table(self, flow):
        row_position = self.flow_table.rowCount()
        self.flow_table.insertRow(row_position)
        for col, (key, value) in enumerate(flow.items()):
            self.flow_table.setItem(row_position, col, QTableWidgetItem(str(value)))
        self.flows.append(flow)

    def export_flows(self):
        filename, _ = QFileDialog.getSaveFileName(self, "Export Flows", "", "CSV Files (*.csv)")
        if filename:
            with open(filename, 'w', newline='') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=self.flows[0].keys() if self.flows else [])
                writer.writeheader()
                for flow in self.flows:
                    writer.writerow(flow)
            self.update_log(f"Exported {len(self.flows)} flows to {filename}")

def parse_arguments():
    parser = argparse.ArgumentParser(description="Generate fake IPFIX traffic")
    parser.add_argument("--source", help="Comma-separated list of source IP addresses to spoof")
    parser.add_argument("--destination", help="Destination IP address")
    parser.add_argument("--port", type=int, default=2055, help="Destination port (default: 2055)")
    parser.add_argument("--flows", type=int, default=0, help="Number of flows to generate (0 for infinite)")
    parser.add_argument("--interval", type=float, default=1.0, help="Interval between flow generations in seconds")
    parser.add_argument("--packets-per-interval", type=int, default=1, help="Number of packets to send in each interval")
    parser.add_argument("--flows-per-packet", type=int, default=0, help="Number of flows per packet (0 for random 1-5)")
    parser.add_argument("--gui", action="store_true", help="Launch with GUI")
    parser.add_argument("--flow-src-ips", help="Comma-separated list of source IP addresses or CIDR ranges for flows")
    parser.add_argument("--flow-dst-ips", help="Comma-separated list of destination IP addresses or CIDR ranges for flows")
    return parser.parse_args()

if __name__ == '__main__':
    args = parse_arguments()
    
    if args.gui:
        app = QApplication(sys.argv)
        ex = IPFIXGeneratorGUI(args)
        sys.exit(app.exec_())
    else:
        source_ips = [ip.strip() for ip in args.source.split(',')] if args.source else []
        flow_src_ips = parse_ip_ranges(args.flow_src_ips) if args.flow_src_ips else []
        flow_dst_ips = parse_ip_ranges(args.flow_dst_ips) if args.flow_dst_ips else []
        generator = IPFIXGeneratorThread(args.source, args.destination, args.port, args.flows, args.interval, args.packets_per_interval, args.flows_per_packet, flow_src_ips, flow_dst_ips)
        generator.update_signal.connect(print)  # Print updates to console
        generator.run()